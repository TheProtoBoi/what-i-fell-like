<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>GD Browser Clone+</title>
<style>
body{
    margin:0;
    overflow:hidden;
    background:black;
    font-family:Arial;
    color:white;
}
canvas{
    display:block;
    margin:0 auto;
}
#menu{
    position:absolute;
    top:20px;
    width:100%;
    text-align:center;
    z-index:10;
}
button{
    padding:10px 20px;
    margin:5px;
    font-size:18px;
    background:#00ffff;
    border:none;
    cursor:pointer;
}
</style>
</head>
<body>

<div id="menu"></div>
<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = 500;

const grid = 40;
const speed = 6;
const floorY = 460;

let mode = "menu";
let cameraX = 0;
let currentLevel = null;

// Input tracking
let inputJump = false;

// Levels storage
let levels = JSON.parse(localStorage.getItem("gd_levels")) || [
{
name:"Demo",
objects:[
{type:"block",x:400,y:420},
{type:"spike",x:480,y:420},
{type:"pad",x:640,y:420, used:false},
{type:"orb",x:820,y:300, used:false}
]
}
];

function saveLevels(){
    localStorage.setItem("gd_levels",JSON.stringify(levels));
}

// Player object
const player={
    x:100,
    y:floorY-40,
    size:40,
    dy:0,
    gravity:0.9,
    jump:16,
    grounded:false,
    rotation:0
};

function reset(){
    player.x=100;
    player.y=floorY-player.size;
    player.dy=0;
    cameraX=0;
}

// Menu and level selection
function showMenu(){
    mode="menu";
    menu.innerHTML=
    `<h1>GD Clone+</h1>
    <button onclick="playSelect()">Play</button>
    <button onclick="openEditor()">Editor</button>`;
}

function playSelect(){
    mode="select";
    let html="<h2>Select Level</h2>";
    levels.forEach((l,i)=>{
        html+=`<button onclick="startLevel(${i})">${l.name}</button>`;
    });
    html+=`<br><button onclick="showMenu()">Back</button>`;
    menu.innerHTML=html;
}

function startLevel(i){
    currentLevel=levels[i];
    mode="play";
    reset();
    menu.innerHTML=`<button onclick="showMenu()">Exit</button>`;
}

function openEditor(){
    mode="editor";
    currentLevel={name:"New Level",objects:[]};
    menu.innerHTML=
    `<h2>Editor</h2>
    <p>Click=Block | Shift+Click=Spike | 1=Pad | 2=Orb</p>
    <button onclick="saveLevel()">Save</button>
    <button onclick="showMenu()">Back</button>`;
}

function saveLevel(){
    let name=prompt("Level name?");
    if(name){
        currentLevel.name=name;
        levels.push(currentLevel);
        saveLevels();
        showMenu();
    }
}

let placeType="block";

// Input events
document.addEventListener("keydown", e => {
    if(mode==="editor"){
        if(e.key==="1") placeType="pad";
        if(e.key==="2") placeType="orb";
    }
    if(mode==="play" && (e.code==="Space" || e.code==="ArrowUp")) inputJump = true;
});
document.addEventListener("keyup", e => {
    if(mode==="play" && (e.code==="Space" || e.code==="ArrowUp")) inputJump = false;
});
canvas.addEventListener("mousedown", ()=>{ if(mode==="play") inputJump = true; });
canvas.addEventListener("mouseup", ()=>{ if(mode==="play") inputJump = false; });

// Editor click
canvas.addEventListener("click", e => {
    if(mode==="editor"){
        const rect = canvas.getBoundingClientRect();
        let x = Math.floor((e.clientX - rect.left + cameraX)/grid)*grid;
        let y = Math.floor((e.clientY - rect.top)/grid)*grid;
        if(y >= floorY - grid) y = floorY - grid;
        let type = e.shiftKey ? "spike" : placeType;
        currentLevel.objects.push({type,x,y, used:false});
    }
});

// Collision helpers
function rectCollide(a){
    return player.x < a.x+grid &&
           player.x+player.size > a.x &&
           player.y < a.y+grid &&
           player.y+player.size > a.y;
}

function circleCollide(o){
    let px = player.x+20;
    let py = player.y+20;
    let ox = o.x+20;
    let oy = o.y+20;
    let dist = Math.hypot(px-ox, py-oy);
    return dist < 30;
}

// Draw objects
function drawObject(o){
    let x = o.x - cameraX;
    if(o.type==="block"){
        ctx.fillStyle="#00ffff";
        ctx.fillRect(x,o.y,grid,grid);
        ctx.strokeStyle="white";
        ctx.strokeRect(x,o.y,grid,grid);
    }
    if(o.type==="spike"){
        ctx.fillStyle="#ff2a2a";
        ctx.beginPath();
        ctx.moveTo(x,o.y+grid);
        ctx.lineTo(x+grid/2,o.y);
        ctx.lineTo(x+grid,o.y+grid);
        ctx.fill();
    }
    if(o.type==="pad"){
        ctx.fillStyle="rgba(0,255,0,0.3)";
        ctx.fillRect(x,o.y+20,grid,20);
        ctx.fillStyle="lime";
        ctx.fillRect(x+5,o.y+25,grid-10,10);
    }
    if(o.type==="orb"){
        ctx.beginPath();
        ctx.arc(x+20,o.y+20,18,0,Math.PI*2);
        ctx.fillStyle="rgba(255,255,0,0.3)";
        ctx.fill();
        ctx.beginPath();
        ctx.arc(x+20,o.y+20,12,0,Math.PI*2);
        ctx.fillStyle="yellow";
        ctx.fill();
    }
}

// Background
let bgHue=0;
function drawBackground(){
    bgHue+=0.5;
    let grad=ctx.createLinearGradient(0,0,0,canvas.height);
    grad.addColorStop(0,`hsl(${bgHue},70%,25%)`);
    grad.addColorStop(1,"black");
    ctx.fillStyle=grad;
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // floor
    ctx.fillStyle="#111";
    ctx.fillRect(0,floorY,canvas.width,canvas.height-floorY);
    ctx.strokeStyle="#00ffff";
    ctx.lineWidth=4;
    ctx.beginPath();
    ctx.moveTo(0,floorY);
    ctx.lineTo(canvas.width,floorY);
    ctx.stroke();
}

// Update loop
function update(){
    drawBackground();

    if(mode==="play"){
        player.x += speed;
        cameraX += speed;

        player.dy += player.gravity;
        player.y += player.dy;
        player.grounded = false;

        // Pad/orb triggers
        currentLevel.objects.forEach(o=>{
            drawObject(o);

            if(o.type==="block" && rectCollide(o) && player.dy>=0){
                player.y = o.y - player.size;
                player.dy = 0;
                player.grounded = true;
            }

            if(o.type==="spike" && rectCollide(o)){
                reset();
            }

            if(o.type==="pad"){
                if(rectCollide(o) && !o.used){
                    player.dy = -player.jump*1.6;
                    o.used = true;
                } else if(!rectCollide(o)){
                    o.used = false;
                }
            }

            if(o.type==="orb"){
                if(circleCollide(o) && inputJump && !o.used){
                    player.dy = -player.jump*1.3;
                    o.used = true;
                } else if(!circleCollide(o)){
                    o.used = false;
                }
            }
        });

        // Ground jump
        if(player.y + player.size >= floorY){
            player.y = floorY - player.size;
            player.dy = 0;
            player.grounded = true;
        }

        // Air jump (space)
        if(inputJump && player.grounded){
            player.dy = -player.jump;
        }

        // Player rotation
        player.rotation += 0.1;
        ctx.save();
        ctx.translate(player.x-cameraX+20,player.y+20);
        ctx.rotate(player.rotation);
        ctx.fillStyle="white";
        ctx.fillRect(-20,-20,40,40);
        ctx.restore();
    }

    requestAnimationFrame(update);
}

update();
showMenu();
</script>
</body>
</html>
